Предыдущая лекция | &nbsp; | Следующая лекция
:----------------:|:----------:|:----------------:
[Проект погода (начало): геолокация, http(s)-запросы, разбор json, ImageView.](./weather.md) | [Содержание](../readme.md#практика-разработка-мобильных-приложений) | [Проект погода (продолжение): SplashScreen (заставка). Выбор города. Выбор и отображение массива значений (почасовая, ежедневная). Разбор XML.](./weather2.md)


# Intent (намерение)

* [Общее](#Общее)
* [Явные намерения](#Явные-намерения)
* [Неявные намерения](#Неявные-намерения)
* [Константы действия](#Константы-действия)
* [Константы категорий](#Константы-категорий)
* [Методы](#Методы)
* [Фильтры намерений и запуск заданий](#Фильтры-намерений-и-запуск-заданий)
* [Принцип работы фильтров намерений](#Принцип-работы-фильтров-намерений)
* [Поиск и использование намерения, с помощью которого была запущена активность](#Поиск-и-использование-намерения-с-помощью-которого-была-запущена-активность)
* [Делегирование ответственности](#Делегирование-ответственности)

### Общее

Намерение (Intent) - это механизм для описания одной операции - выбрать фотографию, отправить письмо, сделать звонок, запустить браузер и перейти по указанному адресу. В Android-приложениях многие операции работают через намерения.

Наиболее распространённый сценарий использования намерения - запуск другой активности в своём приложении.

Но это не единственный вариант использования намерения. Также можно использовать для объявления о запуске активности или сервиса, направленных на выполнение каких-либо действий (как правило, речь о работе с определенной частью данных) или для передачи уведомлений о том, что произошло некое событие (или действие).

Намерения могут применяться для трансляции сообщений по системе. Любое приложение способно зарегистрировать широковещательный приёмник и отслеживать эти намерения с возможностью на них реагировать. Это позволяет создавать приложения, использующие событийную модель, в основе которой лежат внутренние, системные или сторонние события, передаваемые внешними программами.

Android транслирует намерения для объявления о системных событиях, например об изменениях в состоянии сетевого подключения или в уровне заряда батареи. Системные приложения в Android, такие как программы дозвона или управления SMS, регистрируют компоненты, отслеживающие заданные намерения, например входящий звонок или получено новое SMS-сообщение, и соответствующим образом реагируют на них.

### Явные намерения

Рассмотрим код для перехода на другую активность в своём приложении:

```kt
val intent = Intent(
    this, 
    AboutActivity::class.name)

startActivity(intent)
```

В намерении мы явно указали имя класса активности во втором параметре. Данный класс у нас прописан в манифесте, и система, просматривая манифест, запустит нужную активность.

Первый параметр – это *Context*. Активность является подклассом **Context**, поэтому мы можем использовать её как *this*.

Таким образом, ваше приложение может иметь десять активностей, и вы можете вызвать любую из них, зная её имя класса. Это явный вызов, где вы явно указываете имя класса для запуска.

![](/img/intent_01.jpg)

После вызова метода создастся новая активность, которая запустится или возобновит свою работу, переместившись на вершину стека активностей.

Также при переходе на другую активность мы можем указать какие-то данные, а принимающая активность должна уметь обработать их. Для этих целей существуют методы типа **putXXX()**. Например, для передачи списка файлов из одной активности в другую:

```java
// У первой активности
ArrayList<File> fileList = new ArrayList<File>();
 
Intent intent = new Intent(
    MainActivity.this, 
    SecondActivity.class);

intent.putExtra(
    "FILES_LIST", 
    fileList);

startActivity(intent);

// У второй активности
ArrayList<File> filelist = 
    (ArrayList<File>)getIntent()
    .getSerializableExtra("FILES_LIST");
```

По похожему сценарию можно передать простые типы и строки.

При работе с действиями, возвращающими данные, нельзя использовать метод *startActivity()*, поскольку он не возвращает результат. Если вы хотите вернуть данные, то должны использовать метод *startActivityForResult()*, приспособленный для работы с обратными вызовами (этот метод считается устаревшим, но нам пока достаточно его).

---

### Неявные намерения

Существует также неявный вызов активности. В этом случае при создании намерения мы используем не имя класса, а указываем параметры *action*, *data*, *category* с определёнными значениями. Система анализирует, что мы тут такого понаписали и начинает подбирать подходящий вариант для запуска. Например, если указали в параметрах адрес веб-страницы, то скорее всего хотим запустить браузер и почитать новость, что Кот Ларри уволен с поста "главного мышелова" резиденции британского премьера.

Впрочем, мы отвлеклись. Комбинация значений в параметрах определяют цель, которую мы хотим достичь. Это может быть открытие ссылки, отправка письма, набор телефонного номера и т.п.

К слову сказать, мы тоже можем прописать в своей активности в фильтрах намерений (**Intent Filter**) набор тех же параметров: *action*, *data*, *category*. И тогда у пользователя может запуститься не только стандартный браузер, но и наша программа.

Иными словами, если параметры намерения совпадают с условиями нашего фильтра, то наше приложение (активность) будет вызвано. Система сканирует активности всех установленных приложений, и если находится несколько подходящих активностей, то Android предоставляет пользователю выбор, какой именно программой следует воспользоваться. Если найдётся только одна подходящая активность, то, естественно, никакого диалога для выбора не будет, и активность запустится автоматически.

![](/img/intent_02.jpg)

Неявные намерения — это механизм, позволяющий запрашивать анонимные компоненты приложений с помощью действий. Вы можете попросить систему запустить активность, выполняющую заданное действие, не зная ничего ни о самой активности, ни о её приложении. Например, мы указываем телефонный номер, но понятия не имеем, какой программой дозвона пользуется пользователь на своём телефоне. Но это уже не наша проблема, пусть пользователь сам выбирает, как ему звонить по номеру, который мы можем ему предоставить.

Создавая новое неявное намерение для передачи в метод *startActivity()*, необходимо назначить действие, которое должно выполниться, а также при желании указать вспомогательный путь URI к тем данным, что нужно обработать. Вы также можете передать дополнительные данные в другую активность, используя параметр намерения *extras*.

При применении этого намерения для запуска активности система во время работы приложения сама найдёт класс компонента, который лучше всего подходит для заданного действия, учитывая указанный тип данных. Это значит, что вы можете создавать проекты, используя возможности других приложений и не зная при этом, как они называются и какую функциональность предоставляют.

Простой пример создания намерения с предопределённым действием ACTION_VIEW для запуска браузера и перехода на нужный адрес:

```kt
val address = Uri.parse(
    "http://developer.alexanderklimov.ru")

val openLinkIntent = Intent(
    Intent.ACTION_VIEW, 
    address)

try {
    startActivity(openLinkIntent)
} catch (e: ActivityNotFoundException) {
    Log.e("KEI", "Can't handle intent $intent")
}
```

В данном случае действие ACTION_VIEW означает просмотр чего-либо. Мы указали нужные данные (адрес), и происходит запуск новой активности (браузера). При этом исходная активность приостанавливается и переходит в фоновый режим. Когда пользователь нажимает на кнопку Back, то он возвращается к исходной активности. Обратите внимание, что мы нигде не указываем конкретную программу-браузер типа Chrome, Opera и т.п.

В каждом случае Android находит соответствующую активность, чтобы ответить на намерение, инициализируя её в случае необходимости.

Приложения могут также создавать свои собственные типы намерений и позволять другим приложениям вызывать.

Следует помнить, что нет никакой гарантии, что приложение, способное обработать ваше намерение, будет установлено и доступно на устройстве. Конечно, вероятность того, что у пользователя не будет звонилки, достаточна низка. А если приложение установлено на планшете без телефонного модуля? А если появятся холодильники или стиральные машины с Android на борту? Если ваш Intent не может быть запущен, то система выбросит исключение **ActivityNotFoundException**, которое мы должны перехватить.

Объект **Intent** содержит информацию, представляющую интерес для компонента, который получает намерение, и данные, которые передаются этому компоненту. Кроме того, объект **Intent** содержит информацию, представляющую интерес для системы Android, — имя компонента, который должен обработать намерение и набор параметров запуска этого компонента. Как правило, объект **Intent** может содержать следующие поля:

* *Имя компонента* - имя, который должен обработать намерение. Используется объект **ComponentName**, который является комбинацией полного имени класса целевого компонента (например, "MainActivity") и набора имени пакета в файле манифеста приложения, где компонент постоянно находится (например, "com.samples.yourproject"). Составляющее имя является дополнительным. Если оно установлено, объект **Intent** поставляет образцу определяемого класса. Если имя не установлено, Android использует другую информацию в объекте Intent, чтобы определить местонахождение подходящего адресата. Составляющее имя устанавливается методами setComponent(), setClass() или setClassName() и читается методом getComponent();

* *Действие* - определяет действие, которое будет выполнено. Класс *Intent* содержит множество констант действия. Название метода определяет ряд параметров и возвращаемое значение. Вы можете также определить собственные действия для активизации активности. В этом случае вы должны включать имя пакета приложения в качестве префикса, например com.samples.yourproject.CUSTOM_ACTiON. Действие в объекте Intent устанавливается в методе setAction() и читается методом getAction();

* *Данные* - это **URI** данных и тип **MIME** для этих данных. Разные активности соединены с разными видами спецификаций данных.

* *Категория* - строка, содержащая дополнительную информацию о виде компонента, который должен обработать намерение. В объект Intent можно поместить любое количество описаний категорий. Класс Intent определяет несколько констант CATEGORY, например, CATEGORY_BROWSABLE

* *Дополнения* - пары ключ-значения для дополнительной информации, которую нужно поставить компоненту, обращающемуся с намерением. Например, действие ACTION_TIMEZONE_CHANGED имеет дополнение time-zone, которое идентифицирует новый часовой пояс, ACTION_HEADSET_PLUG имеет дополнение state, указывающее, включены ли наушники или отключены, а также дополнение name для типа наушников. Объект Intent имеет ряд методов put...() для вставки различных типов дополнительных данных и подобного набора методов get...() для чтения данных. Дополнения устанавливаются и читаются как объекты Bundle с использованием методов putExtras() и getExtras();

* *Флаги* - указывают системе, как запускать активность (например, какому заданию должна принадлежать активность) и как обработать это после того, как активность запустили (например, принадлежит ли она списку недавних активностей). Все флаги определены в классе Intent.

Система и приложения, которые идут в комплекте с платформой, также используют объекты Intent для активизации определённых системой компонентов (например, различных приложений и служб при загрузке системы).

---

### Константы действия

* ACTION_ANSWER — Открывает активность, которая связана с входящими звонками. Это действие обрабатывается стандартным экраном для приёма звонков;
* ACTION_CALL — инициализирует обращение по телефону;
* ACTION_DELETE — Запускает активность, с помощью которой можно удалить данные, указанные в пути URI внутри намерения;
* ACTION_EDIT — Отображает данные для редактирования пользователем
* ACTION_INSERT — Открывает активность для вставки в Курсор (Cursor) нового элемента, указанного с помощью пути URI. Дочерняя активность, вызванная с этим действием, должна вернуть URI, ссылающийся на вставленный элемент
* ACTION_HEADSET_PLUG - Подключение наушников
* ACTION_MAIN — Запускается как начальная активность задания
* ACTION_PICK - Загружает дочернюю Активность, позволяющую выбрать элемент из источника данных, указанный с помощью пути URI. При закрытии должен возвращаться URI, ссылающийся на выбранный элемент. Активность, которая будет запущена, зависит от типа выбранных данных, например при передаче пути content://contacts/people вызовется системный список контактов;
* ACTION_SEARCH — Запускает активность для выполнения поиска. Поисковый запрос хранится в виде строки в дополнительном параметре намерения по ключу SearchManager.QUERY
* ACTION_SEND — Загружает экран для отправки данных, указанных в намерении. Контакт-получатель должен быть выбран с помощью полученной активности. Используйте метод setType, чтобы указать тип MIME для передаваемых данных. Эти данные должны храниться в параметре намерения extras с ключами EXTRA_TEXT или EXTRA_STREAM, в зависимости от типа. В случае с электронной почтой стандартное приложение в Android также принимает дополнительные параметры по ключам EXTRA_EMAIL, EXTRA_CC, EXTRA_BCC и EXTRA_SUBJECT. Используйте действие ACTION_SEND только в тех случаях, когда данные нужно передать удаленному адресату (а не другой программе на том же устройстве)
* ACTION_SENDTO — Открывает активность для отправки сообщений контакту, указанному в пути URI, который передаётся через намерение
* ACTION_SYNC — Синхронизирует данные сервера с данными мобильного устройства
* ACTION_TIMEZONE_CHANGED - Смена часового пояса
* ACTION_VIEW — Наиболее распространённое общее действие. Для данных, передаваемых с помощью пути URI в намерении, ищется наиболее подходящий способ вывода. Выбор приложения зависит от схемы (протокола) данных. Стандартные адреса http: будут открываться в браузере, адреса tel: — в приложении для дозвона, geo: — в программе Google Maps, а данные о контакте — отображатся в приложении для управления контактной информацией
* ACTION_WEB_SEARCH — Открывает активность, которая ведет поиск в интернете, основываясь на тексте, переданном с помощью пути URI (как правило, при этом запускается браузер)

---

### Константы категорий

* CATEGORY_BROWSABLE — активность может быть безопасно вызвана браузером, чтобы отобразить ссылочные данные, например, изображение или почтовое сообщение
* CATEGORY_HOME — активность отображает Home Screen, первый экран, который пользователь видит после включения устройства и загрузки системы, или когда нажимает клавишу HOME
* CATEGORY_LAUNCHER — активность может быть начальной деятельностью задания из списка приложений в группе Application Launcher устройства

---

### Методы

Для работы с категориями в классе Intent определена группа методов:

* addCategory() — помещает категорию в объект Intent
* removeCategory() — удаляет категорию, которая была добавлена ранее
* getCategories() — получает набор всех категорий, находящихся в настоящее время в объекте Intent

---

### Фильтры намерений и запуск заданий

Если намерение запрашивает выполнение какого-либо действия с определённым набором данных, то системе нужно уметь выбрать приложение (или компонент) для обслуживания этого запроса. На помощь приходят фильтры намерений, которые используются для регистрации активностей, сервисов и широковещательных приёмников в качестве компонентов, способных выполнять заданные действия с конкретным видом данных. С помощью этих фильтров также регистрируются широковещательные приёмники, настроенные на трансляцию намерением заданного действия или события.

Задействуя фильтры намерений, приложения объявляют, что они могут отвечать на действия, запрашиваемые любой другой программой, установленной на устройстве. Чтобы зарегистрировать компонент приложения в качестве потенциального обработчика намерений, нужно добавить тег `<intent-filter>` в узел компонента в манифесте.

В фильтре намерений декларируется только три составляющих объекта Intent: *действие*, *данные*, *категория*. Дополнения и флаги не играют никакой роли в принятии решения, какой компонент получает намерение.

Например, в любом приложении есть главная активность, которая устанавливается как точка входа для задания:

```xml
<activity 
    android:name=".HelloWorldActivity" 
    android:label="@string/app_name"> 
    <intent-filter> 
        <action android:name="android.intent.action.MAIN"/> 
        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter> 
</activity> 
```

Фильтр такого вида в элементе `<action>` помечает активность, как запускаемую по умолчанию. Элемент `<category>` заставляет значок и метку для деятельности отображаться на панели Application Launcher, давая пользователям возможность запускать задание и возвращаться к этому заданию в любое время после того, как оно было запущено.

Внутри узла Фильтра намерений можно использовать такие теги (и соответствующие атрибуты).

* **action** - Использует атрибут android:name, чтобы задать название действия, которое будет обслуживаться. Каждый фильтр намерений должен иметь один (и только один) тег action. Действия должны быть представлены в виде уникальных строк, которые сами себя описывают. Рекомендуется выбирать названия, основываясь на соглашении об именовании пакетов в Java.

* **сategory** - Использует атрибут android:name, чтобы указать, при каких обстоятельствах должно обслуживаться действие. Каждый тег intent-filter способен содержать несколько тегов category. Вы можете задать собственные категории или же брать стандартные значения, предоставляемые системой
    * **ALTERNATIVE** - Наличие данной категории говорит о том, что действие должно быть доступно в качестве альтернативного тому, которое выполняется по умолчанию для элемента этого типа данных. Например, если действие по умолчанию для контакта — просмотр, то в качестве альтернативы его также можно редактировать
    * **SELECTED_ALTERNATIVE** - То же самое, что и ALTERNATIVE, но вместо одиночного действия с использованием утверждения намерения, которое описано выше, применяется в тех случаях, когда нужен список различных возможностей. Одной из функций фильтра намерений может стать динамическое заполнение контекстного меню с помощью действий.
    * **BROWSABLE** - Говорит о том, что действие доступно из браузера. Когда намерение срабатывает в браузере, оно всегда содержит данную категорию. Если вы хотите, чтобы приложение реагировало на действия, инициированные браузером (такие как перехват ссылок на конкретный сайт), то должны добавить в его манифест категорию BROWSABLE.
    * **DEFAULT** - Установите эту категорию, чтобы сделать компонент обработчиком по умолчанию для действия, выполняемого с указанным типом данных внутри Фильтра намерений. Это необходимо и для Активностей, которые запускаются с помощью явных Намерений
    * **GADGET** - Наличие этой категории указывает на то, что данная активность может запускаться внутри другой активности.
    * **HOME** - Устанавливая эту категорию и не указывая при этом действия, вы создаете альтернативу для стандартного домашнего экрана.
    * **LAUNCHER** - Используя эту категорию, вы помещаете Активность в окно для запуска приложений.

* **data** - Этот тег дает возможность указать тип данных, с которым может взаимодействовать ваш компонент. При необходимости можно задать несколько тегов data. Чтобы указать, какие именно данные поддерживает ваш компонент, используйте сочетание следующих атрибутов:
    * **android:host** — задаёт доступное имя удалённого сервера (например, google.com);
    * **android:mimetype** — позволяет указать тип данных, которые ваш компонент способен обрабатывать. Для примера: ``<type android: value="vnd.android.cursor.dir/*"/>`` будет соответствовать любому Курсору в Android;
    * **android:path** — задает доступные значения для пути URI (например, /transport/boats/);
    * **android:port** — указывает доступные порты для заданного сервера;
    * **android:scheme** — требует указать конкретную схему (например, content или http).

---

### Принцип работы фильтров намерений

При использовании метода startActivity() передаваемое неявное намерение, как правило, доходит лишь до одной активности. Если для выполнения заданного действия с указанными данными годятся сразу несколько активностей, пользователю предоставляется список выбора. Процесс, когда решается, какую активность лучше запустить, называется Утверждением намерений. Его цель — найти наиболее подходящий фильтр намерений. В целом весь алгоритм работает следующим образом.

1. Android собирает список всех доступных Фильтров намерений из установленных пакетов.
2. Фильтры, которые не соответствуют действию или категории Намерения, удаляются из списка. Совпадение происходит только в том случае, если Фильтр намерений содержит указанное действие (или если действие для него вовсе не задано). Совпадения не произойдёт, только если ни одно из действий Фильтра намерений не будет эквивалентно тому, которое задано в Намерении. Для категорий процесс соответствия более строгий. Фильтр намерений должен включать в себя все категории, заданные в полученном Намерении. Фильтр, для которого категории не указаны, может соответствовать только таким же Намерениям (нет категорий).
3. Наконец, каждая часть пути URI из Намерения сравнивается с тегом data Фильтра намерений. Если в Фильтре указаны схема (протокол), сервер/принадлежность, путь или тип MIME, все эти значения проверяются на соответствие пути URI из Намерения. При любом несовпадении Фильтр будет удален из списка. Если в Фильтре намерений не указано ни одного параметра data, его действие будет распространяться на любые данные.
    * MIME — тип данных, который должен совпасть. При сравнении типов данных вы можете использовать маски, чтобы охватывать все подтипы (например, cats/*). Если в Фильтре намерения указан тип данных, он должен совпасть с тем, который значится в намерении, при отсутствии тега data подойдет любой тип.
    * Схема — это протокольная часть пути URI, например http:, mailto: или tel:.
    * Имя сервера (или принадлежность данных) — часть URI между схемой и самим путём (например, www.google.com). Чтобы совпало имя сервера, схема Фильтра намерений также должна подойти.
    * После имени сервера идёт путь к данным (например, /ig). Путь пройдёт проверку только после схемы и имени сервера, содержащихся в теге.
4. Когда вы неявным образом запускаете Активность и вышеописанный процесс возвращает более одного совпадения, пользователю выводится список со всеми вариантами

---

### Поиск и использование намерения, с помощью которого была запущена активность

Когда программный компонент запускается с помощью неявного намерения, он должен найти действие, которое необходимо осуществить, и данные для него.

Используйте метод *getIntent* (как правило, внутри метода *onCreate*), чтобы извлечь намерение, с помощью которого компонент запущен.

```java
@Override
public void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.main);
    Intent intent = getIntent();
}
```

Применяйте методы getAction() и getData(), чтобы найти действие и данные, связанные с намерением. Для извлечения дополнительной информации, хранящейся в параметре extras, используйте типизированные методы get<тип>Extra.

```java
String action = intent.getAction();
Uri data = intent.getData();
```

---

### Делегирование ответственности

Задействуйте метод startNextMatchingActivity() для делегирования ответственности за обработку действия следующему компоненту, который лучше всего для этого подходит.

```java
Intent intent = getIntent();
if (isDuringBreak)
    startNextMatchingActivity(intent);
```

Это позволяет добавлять дополнительные условия для компонентов, которые ограничат сферу их применения рамками утверждения Намерений. В некоторых случаях ваш компонент может выполнить некоторые операции или предложить пользователю выбор, прежде чем передать Намерение другому компоненту.

---

### ACTION_PICK

До сих пор мы в основном рассматривали намерения или действия, которые обычно активируют другую активность, не ожидая получить в ответ на это результат. Теперь рассмотрим более сложное действие, которое возвращает значение после того, как будет активировано. ACTION_PICK - это обобщённое название для таких действий.

Принцип ACTION_PICK заключается в том, чтобы запустить активность, отображающую список элементов. После этого активность должна предоставлять пользователю возможность выбора элемента из этого списка. Когда пользователь выберет элемент, активность возвратит URI выбранного элемента вызывающей стороне. Таким образом, можно многократно использовать функцию UI для выбора нескольких элементов определённого типа.

Следующий код выведет диалоговое окно со списком всех возможных программ, которые могут запустить активность с данными, так как мы не указываем конкретный тип (setType("*/*")):

```java
// Показываем все программы для запуска
Intent intent = new Intent(Intent.ACTION_PICK);
intent.setType("*/*");
startActivityForResult(intent, 1);
```

Если мы укажем конкретный тип данных, которые нас интересует, то список программ существенно сузится. Например, если указать intent.setType("image/*");, то можем увидеть только системную программу Галерея для просмотра картинок (у пользователя могут быть установлены программы, которые также предназначены для просмотра картинок, поэтому список может отличаться).

---

### ACTION_SEND

Очень распространённое намерение. Используйте метод setType(), чтобы указать тип MIME для передаваемых данных. Эти данные должны храниться в параметре намерения extras с ключами EXTRA_TEXT или EXTRA_STREAM, в зависимости от типа. В случае с электронной почтой стандартное приложение в Android также принимает дополнительные параметры по ключам EXTRA_EMAIL, EXTRA_CC, EXTRA_BCC и EXTRA_SUBJECT.

Если есть установленное приложение с фильтром, который соответствует ACTION_SEND и MIME-типу text/plain, система Android запустит его, а если будет найдено более одного приложения, то система отобразит диалог выбора, который позволяет пользователю выбрать приложение.

Пример отправки письма

Если ваша активность хочет обрабатывать подобные намерения, то она должна содержать следующие данные:

```xml
<activity android:name="ShareActivity">
    <intent-filter>
        <action android:name="android.intent.action.SEND"/>
        <category android:name="android.intent.category.DEFAULT"/>
        <data android:mimeType="text/plain"/>
        <data android:mimeType="image/*"/>
    </intent-filter>
</activity>
```

Имя сообщает Android, что активность может обрабатывать ACTION_SEND.

Фильтр должен включать категорию DEFAULT, в противном случае он не сможет получать неявные намерения.

Указываем типы данных, которые могут обрабатываться активностью.

---

### ACTION_GET_CONTENT (Выбрать файл)

Если вы не хотите писать собственный менеджер файлов, а готовы использовать готовые приложения для выбора файла, то можете использовать следующий код:

```java
public class PickFileActivity extends Activity {
    TextView textView;
 
    private static final int PICKFILE_RESULT_CODE = 1;
 
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
      
        Button buttonPick = findViewById(R.id.buttonpick);
        textView = findViewById(R.id.textView);
      
        buttonPick.setOnClickListener(new Button.OnClickListener(){
        @Override
        public void onClick(View arg0) {
            Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
            intent.setType("file/*");
            startActivityForResult(intent,PICKFILE_RESULT_CODE);
        }});
    }

    @Override
    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
        switch(requestCode){
            case PICKFILE_RESULT_CODE:
                if(resultCode == RESULT_OK){
                    String FilePath = data.getData().getPath();
                    textView.setText(FilePath);
                }
                break;
        }
    }
}
```

Только вы должны быть уверены, что у пользователя есть программа, способная работать с файлами.

В коде мы получаем полный путь к файлу через метод getPath(). Если вам нужно получить раздельно имя каталога и имя файла, то потребуется небольшая модификация:

```java
@Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    switch(requestCode){
        case PICKFILE_RESULT_CODE:
            if(resultCode == RESULT_OK){
                String FilePath = data.getData().getPath();
                String FileName = data.getData().getLastPathSegment();
                int lastPos = FilePath.length() - FileName.length();
                String Folder = FilePath.substring(0, lastPos);
  
                textFile.setText("Full Path: \n" + FilePath + "\n");
                textFolder.setText("Folder: \n" + Folder + "\n");
                textFileName.setText("File Name: \n" + FileName + "\n");
            }
            break;
    }
}
```

--

### Диалоговое окно выбора

При выборе из списка программ пользователь может выбрать программу по умолчанию, которая будет автоматически запускаться при выбранном намерении. В этом случае диалоговое окно выводиться не будет. Но можно принудительно выводить диалоговое окно при помощи метода createChooser() и пользователю придётся каждый раз выбирать нужную активность:

```java
Intent intent = new Intent(Intent.ACTION_SEND);
intent.setType("text/plain");
intent.putExtra(Intent.EXTRA_TEXT, messageText);
Intent chosenIntent = Intent.createChooser(intent, "Заголовок в диалоговом окне");
startActivity(chosenIntent);
```

Если на устройстве не будет подходящих активностей для запуска, то createChooser() обработает данную ситуацию и выведет соответствующее сообщение. В этом заключается его преимущество. Если передать методу startActivity() намерение, для которого не найдётся подходящей активности, то возникнет исключение ActivityNotFoundException. И вам придётся перехватывать его в блоке try/catch, чтобы избежать аварийного завершения приложения.

---

### Другие примеры использования намерений

Запустить другую активность вашего приложения можно не только стандартным способом, но и другим немного странным способом. Прописываем в манифесте у второй активности мета-данные:

```xml
<activity
    android:name=".SecondActivity"
    android:label="@string/title_activity_second"
    android:theme="@style/AppTheme.NoActionBar">

    <intent-filter>
        <action android:name="ru.alexanderklimov.helloworld.second.SECOND" />
        <category android:name="android.intent.category.DEFAULT" />
    </intent-filter>
</activity>
```

Запускаем активность по щелчку кнопки.

```java
Intent intent  = new Intent("ru.alexanderklimov.helloworld.second.SECOND");
// intent.putExtra("something", 2); // по желанию
startActivity(intent);
```

---

### Открыть ссылку в браузере

```java
Uri address = Uri.parse("http://developer.alexanderklimov.ru/android");
Intent openlink = new Intent(Intent.ACTION_VIEW, address);
startActivity(openlink);
```

Данный код запустит браузер с указанной ссылкой. Если ссылка ведёт на YouTube, то откроется стандартное приложение для YouTube. Также можно открыть стандартный клиент Android Market с ссылкой на какое-либо приложение. Для этого необходимо в параметр URI передать ссылку вида `market://search?q=search query`, где `search query` необходимо заменить соответствующим поисковым запросом.

---

### YouTube

Можно запустить конкретно приложение YouTube

```java
// constant value of package & class name of YouTube app
public static final String YOUTUBE_PACKAGE_NAME = "com.google.android.youtube";
public static final String YOUTUBE_CLASS_NAME = "com.google.android.youtube.WatchActivity";

//Launch Youtube to watch an URL
public static void launchYoutube(Context context, String url) {
	Intent intent = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse(url));        
    intent.setClassName(YOUTUBE_PACKAGE_NAME, YOUTUBE_CLASS_NAME);        
    context.startActivity(intent);
}
```

```

### Поисковый запрос

Можно отправить поисковый запрос в Гугл:

```java
String q = "котёнок";

Intent intent = new Intent(
    Intent.ACTION_WEB_SEARCH);

intent.putExtra(
    SearchManager.QUERY, 
    q);

if (intent.resolveActivity(getPackageManager()) != null) {
    startActivity(intent);
}
```

---

### Проиграть MP4-файл (ACTION_VIEW)

```java
// файл выбирается из списка
@Override
protected void onListItemClick(ListView l, View v,
    int position, long id) {
    //super.onListItemClick(l, v, position, id);
 
    String uriString = l.getItemAtPosition(position).toString();
    Uri intentUri = Uri.parse(uriString);
   
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_VIEW);
    intent.setDataAndType(intentUri, "video/mp4");
    startActivity(intent);
}
```

---

### Запустить музыкальный проигрыватель

Запускаем программу Музыка:

```java
if (android.os.Build.VERSION.SDK_INT >= 15) {
	Intent intent = Intent.makeMainSelectorActivity(Intent.ACTION_MAIN,
			Intent.CATEGORY_APP_MUSIC);
	intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);// Min SDK 15
	startActivity(intent);
} else {
	Intent intent = new Intent(MediaStore.INTENT_ACTION_MUSIC_PLAYER); //"android.intent.action.MUSIC_PLAYER"
	startActivity(intent);
}
```

---

### Настройки

Можно открыть различные экраны из приложения "Настройки":

```java
String intent1 = Settings.ACTION_APPLICATION_SETTINGS; // Приложения. Вкладка Сторонние приложения
String intent2 = Settings.ACTION_WIRELESS_SETTINGS; // Беспроводные сети
String intent3 = Settings.ACTION_SETTINGS; // Основное окно приложения Настройки
String intent4 = Settings.ACTION_DATA_ROAMING_SETTINGS; // роуминг
String intent5 = Settings.ACTION_LOCALE_SETTINGS; // настройки локали
String intent6 = Settings.ACTION_INTERNAL_STORAGE_SETTINGS; // настройки внутреннего хранилища
String intent7 = Settings.ACTION_MEMORY_CARD_SETTINGS; // настройка карты-памяти
String intent8 = Settings.ACTION_FINGERPRINT_ENROLL; // настройка Fingerprint
String intent9 = Settings.ACTION_HOME_SETTINGS; // настройка Default apps API 21
String intentX = Settings.ACTION_NETWORK_OPERATOR_SETTINGS; // настройка Mobile network 
String intentX = Settings.ACTION_NOTIFICATION_POLICY_ACCESS_SETTINGS; // настройка уведомлений Do Not Disturb access API 23
String intentX = Settings.ACTION_USAGE_ACCESS_SETTINGS; Apps with usage access API 21
String intentX = Settings.ACTION_PRINT_SETTINGS; // Printing
String intentX = Settings.ACTION_PRIVACY_SETTINGS; // Backup
String intentX = Settings.ACTION_SOUND_SETTINGS; // Sound
String intentX = Settings.ACTION_USER_DICTIONARY_SETTINGS; // Personal dictionary
String intentX = Settings.ACTION_VOICE_INPUT_SETTINGS; // Assist & voice input API 21
String intentX = Settings.ACTION_VPN_SETTINGS; // VPN API 24
String intentX = Settings.ACTION_VR_LISTENER_SETTINGS; // VR helper services API 24
String intentX = Settings.ACTION_ZEN_MODE_PRIORITY_SETTINGS; // Priority only allows API 26

// Подставьте нужную строку
Intent intent = new Intent(Settings.ACTION_DATA_ROAMING_SETTINGS);
if (intent.resolveActivity(getPackageManager()) != null) {
    startActivity(intentX);
}
```

Предыдущая лекция | &nbsp; | Следующая лекция
:----------------:|:----------:|:----------------:
[Проект погода (начало): геолокация, http(s)-запросы, разбор json, ImageView.](./weather.md) | [Содержание](../readme.md#практика-разработка-мобильных-приложений) | [Проект погода (продолжение): SplashScreen (заставка). Выбор города. Выбор и отображение массива значений (почасовая, ежедневная). Разбор XML.](./weather2.md)
